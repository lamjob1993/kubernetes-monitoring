# Кластер K8s на примере развернутых в нём Java приложений

## **Внутренняя структура кредитного конвейера Java развернутого в кластере K8s (реальный пример для легенды):**

### **Описание системы**

1. **Бэкенд на Java**  
   - Система построена на языке программирования Java, где основная логика реализована в виде микросервисов (адаптеров).  
   - Всего развернуто 30 адаптеров, каждый из которых представляет собой отдельный `jar`-файл, упакованный в контейнер Docker. Эти адаптеры взаимодействуют друг с другом через API .  

2. **Архитектура Kubernetes**  
   - Адаптеры развернуты в Kubernetes на двух нодах:  
     - **Нода 1**: мастер-кластер (основная группа серверов) с подами внутри.  
     - **Нода 2**: резервный кластер, идентичный первой ноде для обеспечения отказоустойчивости.  
   - Каждый адаптер работает в рамках подов — минимальных абстракций Kubernetes над контейнерами. На один адаптер приходится 2-3 пода для повышения надежности и масштабируемости .  

3. **Типы адаптеров**  
   - Адаптеры выполняют различные задачи в рамках кредитного конвейера:  
     - **Калькулятор-адаптер**: рассчитывает параметры кредита.  
     - **Документ-адаптер**: предоставляет подписанные банком документы для клиента.  
     - **Бизнесовые адаптеры**: решают другие бизнес-задачи.  

4. **API-взаимодействие**  
   - Адаптеры взаимодействуют между собой через API-запросы. Например:  
     - Если клиент зависает на этапе расчета кредита, это может быть связано с проблемами в работе калькулятор-адаптера или базы данных PostgreSQL.  
     - Если клиент не может скачать документы, это указывает на проблемы с документ-адаптером.  
   - "Зависание клиента" означает, что пользователь не может завершить действие на сайте (например, расчет кредита или скачивание документов) из-за сбоя в работе одного из адаптеров .  

5. **Мониторинг системы**  
   - Для мониторинга Kubernetes используются следующие инструменты:  
     - **cAdvisor**: собирает метрики с контейнеров (например, использование CPU и памяти).  
     - **kube-state-metrics**: предоставляет метрики состояния объектов Kubernetes (Pods, Deployments, Nodes).  
     - **Prometheus**: забирает метрики от cAdvisor и kube-state-metrics.  
     - **Grafana**: визуализирует данные на дашборде.  
   - Дашборд Kubernetes можно скачать в формате JSON с официального сайта Grafana Labs и настроить под свои нужды .  

6. **Кредитный конвейер**  
   - Кредитный конвейер — это большое Java-приложение, которое объединяет все адаптеры в единую систему.  
   - Каждый адаптер выполняет свою часть работы, а их взаимодействие обеспечивает выполнение бизнес-процессов, таких как оформление кредита или выдача документов .  

---

### **Как работала система?**

1. **Клиент начинает оформление кредита**  
   - Клиент заходит на сайт банка и заполняет форму для расчета кредита.  
   - Сайт отправляет API-запрос калькулятор-адаптеру, который выполняет расчет на основе данных из базы данных PostgreSQL.  

2. **Проблемы с адаптерами**  
   - Если калькулятор-адаптер зависает (например, из-за недоступности базы данных), клиент не может завершить расчет кредита.  
   - Аналогично, если документ-адаптер не отвечает, клиент не может скачать подписанные документы.  

3. **Мониторинг и устранение проблем**  
   - Через Grafana можно отслеживать состояние подов, контейнеров и других объектов Kubernetes.  
   - Если адаптер перестает работать, можно проверить метрики в Grafana, найти проблемный под и перезапустить его через Kubernetes.  

---

Система представляет собой слаженный механизм, где:  
- **Java-адаптеры** выполняют конкретные задачи в рамках кредитного конвейера.  
- **Kubernetes** управляет развертыванием и жизненным циклом адаптеров.  
- **Мониторинг** помогает быстро находить и устранять проблемы в работе системы.  

## **Схема со Spring Actuator (в стиле "больничной" аналогии для простоты восприятия кластера K8s)**  

```mermaid
flowchart TD
    subgraph "Больница (Kubernetes Cluster)"
        subgraph "Палаты (Ноды)"
            Палата1["Палата 1 (Нода 1)"] --> |"Датчики (cAdvisor)"| Мониторы1["CPU/RAM/Диски"]
            Палата2["Палата 2 (Нода 2)"] --> |"Датчики (cAdvisor)"| Мониторы2["CPU/RAM/Диски"]
        end

        subgraph "Пациенты (Адаптеры)"
            Калькулятор["Калькулятор кредитов\n(Java-контейнер)"] --> |"Жалобы\n(API-запросы)"| Документы["Документ-адаптер"]
            Калькулятор --> |"Метрики здоровья\n(Actuator)"| МедКарта1["/actuator/prometheus"]
            Документы --> |"Метрики здоровья\n(Actuator)"| МедКарта2["/actuator/prometheus"]
        end

        МедКарты["Медкарты\n(kube-state-metrics)"] --> |"Статусы пациентов\n(Pods/Deployments)"| ГлавВрач
        Мониторы1 --> |"Показания датчиков"| ГлавВрач
        Мониторы2 --> |"Показания датчиков"| ГлавВрач
        МедКарта1 --> |"Самочувствие пациента"| ГлавВрач
        МедКарта2 --> |"Самочувствие пациента"| ГлавВрач
    end

    ГлавВрач["«Главный врач» (Prometheus)"] --> |"Анализ данных"| Диспетчерская["Диспетчерская (Grafana)"]
    Диспетчерская --> |"Экраны мониторинга"| Администратор["Админ-дежурный"]
    Диспетчерская --> |"Стандартный дашборд"| ЭКГ["Kubernetes\n(как ЭКГ)"]
    Диспетчерская --> |"Кастомные дашборды"| СпецМониторы["Бизнес-метрики"]

    style ГлавВрач fill:#ff9999,stroke:#333
    style Диспетчерская fill:#99ccff,stroke:#333
    style Калькулятор fill:#7f7,stroke:#333
    style Документы fill:#7f7,stroke:#333
```

## **Пояснение ролей**  

### **Как всё устроено в Kubernetes мониторинге (простыми словами)**  

Представьте, что ваш Kubernetes-кластер — это **больница**, а мониторинг — это система наблюдения за пациентами (подами) и оборудованием (нодами).  

### **1. Кто за что отвечает?**  

#### **(1) cAdvisor — «Датчики на пациентах»**  
- **Что делает:**  
  - Замеряет **пульс (CPU), давление (RAM), температуру (Disk I/O)** у каждого контейнера.  
  - Встроен в **kubelet** (как встроенные датчики в больничной койке).  

- **Где смотреть метрики:**  
  - Открыть `https://<нода>:10250/metrics/cadvisor` (но нужны права).  
  - Пример метрик:  
    ```bash
    container_cpu_usage_seconds_total{container="nginx"}  # Сколько CPU съел контейнер
    container_memory_usage_bytes{pod="frontend-123"}      # Сколько RAM заняло
    ```

#### **(2) kube-state-metrics — «Медкарты пациентов»**  
- **Что делает:**  
  - Следит, **кто в коме (CrashLoopBackOff), кто выписан (Completed), кто только поступил (Pending)**.  
  - Не меряет пульс, а фиксирует **состояние** подов, деплойментов и нод.  

- **Где смотреть метрики:**  
  - Обычно работает в поде на порту `8080`.  
  - Пример метрик:  
    ```bash
    kube_pod_status_phase{phase="Running"}  # Сколько подов в работе
    kube_deployment_replicas_unavailable   # Сколько реплик упало
    ```

#### **(3) Spring Actuator — «Журнал самочувствия пациента»**  
**Что делает:**  
- Каждый Java-адаптер ведёт **собственный журнал здоровья**:  
  ```bash
  /actuator/prometheus   # Метрики работы API (сколько запросов, ошибок)
  /actuator/health       # Статус подключений к БД и другим сервисам
  ```
- Пример метрик:  
  ```promql
  http_server_requests_seconds_count{uri="/api/calculate"}  # Сколько раз вызывали калькулятор
  jdbc_connections_active{datasource="postgres"}           # Активные подключения к БД
  ```
**Как Prometheus его использует:**  
1. **Находит адаптеры** через Service Discovery (ищет поды с аннотацией `prometheus.io/scrape=true`).  
2. **Читает журнал** каждые 15 секунд (как врач обходит палаты).  
3. **Фиксирует проблемы**:  
   - Если `http_server_errors_total` растёт → API адаптера сбоит.  
   - Если `jdbc_connections_active` упало до 0 → нет связи с PostgreSQL.  

#### **(4) Prometheus — «Главный врач, который собирает все данные»**  
- **Что делает:**  
  - Ходит по палатам (нодам), **спрашивает у cAdvisor** (как себя чувствуют контейнеры).  
  - Читает **медкарты** из kube-state-metrics (кто жив, кто мёртв).  
  - **Автоматически находит новые поды** (Service Discovery).  

- **Как настраивается:**  
  - В `prometheus.yml` пишутся правила:  
    ```yaml
    scrape_configs:
      - job_name: 'cadvisor'          # Сбор метрик контейнеров
        kubernetes_sd_configs:         # Автообнаружение
          - role: node
      - job_name: 'kube-state-metrics' # Сбор состояния подов
        kubernetes_sd_configs:
          - role: service
    ```

#### **(5) Grafana — «Монитор в приёмном отделении»**  

- **Что делает:**  
  - Берёт данные от Prometheus и рисует **красивые графики**.  
  - Примеры дашбордов:  
    - **«Тяжелые пациенты»** — поды с высокой нагрузкой CPU.  
    - **«Кто в реанимации»** — поды в статусе `CrashLoopBackOff`.  

---

### **Как это помогает при проблемах?**  
#### **Сценарий: «Клиент завис на калькуляции кредита»**  
1. **Админ смотрит в Grafana**:  
   - **cAdvisor**: CPU адаптера-калькулятора > 90% → перегрузка.  
   - **Actuator**: `http_server_requests_seconds_max{uri="/calculate"}` показывает 10 сек (норма: 200 мс).  
   - **kube-state-metrics**: Под в статусе `Running`, но рестартов > 5 за час.  
2. **Вывод**: Калькулятор тормозит из-за медленных запросов к БД.  

#### **Сценарий: «Документы не скачиваются»**  
1. **Actuator показывает**:  
   - `disk_free_bytes` ≈ 0 → закончилось место.  
   - `tomcat_sessions_rejected_total` > 0 → адаптер не справляется с нагрузкой.  
2. **Решение**: Добавить поды или почистить хранилище.  

---

### **Дополнения?**  
1. **Prometheus не «принимает данные», а активно ходит за ними (натравлен на них)** (как врач с обходом).  
2. **Actuator добавлен как критический источник метрик** для бизнес-логики.  
3. **Цветовая маркировка**:  
   - Зелёные блоки — адаптеры (пациенты).  
   - Красный блок — Prometheus (главврач).  
   - Синий блок — Grafana (диспетчерская).  

Схема отражает **полный цикл мониторинга** кредитного конвейера.
